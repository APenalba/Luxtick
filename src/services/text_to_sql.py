"""Text-to-SQL analytics service: executes LLM-generated SQL queries with safety guardrails.

This service uses the READ-ONLY database connection to execute SQL queries
generated by the LLM. Safety measures:
- Read-only PostgreSQL role (can only SELECT)
- Statement timeout (5 seconds, set at the DB role level)
- Row limit (max 1000 rows returned)
- SQL validation (must start with SELECT)
"""

import logging
import uuid
from typing import Any

from sqlalchemy import text

from src.db.session import readonly_session

logger = logging.getLogger(__name__)

MAX_ROWS = 1000
FORBIDDEN_KEYWORDS = [
    "INSERT",
    "UPDATE",
    "DELETE",
    "DROP",
    "ALTER",
    "CREATE",
    "TRUNCATE",
    "GRANT",
    "REVOKE",
    "COPY",
    "EXECUTE",
    "\\\\",  # Prevent psql meta-commands
]


def _validate_sql(sql: str) -> tuple[bool, str]:
    """Validate that a SQL query is safe to execute.

    Returns:
        Tuple of (is_valid, error_message).
    """
    cleaned = sql.strip().rstrip(";").strip()

    if not cleaned:
        return False, "Empty query."

    # Must start with SELECT or WITH (for CTEs)
    upper = cleaned.upper()
    if not (upper.startswith("SELECT") or upper.startswith("WITH")):
        return False, "Only SELECT queries are allowed."

    # Check for forbidden keywords (basic protection layer on top of DB role)
    for keyword in FORBIDDEN_KEYWORDS:
        # Check as whole word to avoid false positives (e.g., "SELECTED")
        if f" {keyword} " in f" {upper} " or upper.startswith(f"{keyword} "):
            return False, f"Query contains forbidden keyword: {keyword}"

    return True, ""


class TextToSQLService:
    """Executes validated, read-only SQL queries against the database."""

    async def execute_query(
        self,
        user_id: uuid.UUID,
        question: str,
        sql_query: str,
    ) -> dict[str, Any]:
        """Execute a read-only SQL query generated by the LLM.

        Args:
            user_id: The current user's ID (for logging/auditing).
            question: The natural language question (for context).
            sql_query: The SQL SELECT query to execute.

        Returns:
            Dict with query results or error information.
        """
        logger.info(
            "Text-to-SQL query for user %s: question='%s', sql='%s'",
            user_id,
            question[:100],
            sql_query[:200],
        )

        # Step 1: Validate the SQL
        is_valid, error = _validate_sql(sql_query)
        if not is_valid:
            logger.warning("SQL validation failed: %s", error)
            return {
                "status": "error",
                "error": f"Query validation failed: {error}",
                "question": question,
            }

        # Step 2: Add LIMIT if not present
        cleaned_sql = sql_query.strip().rstrip(";")
        if "LIMIT" not in cleaned_sql.upper():
            cleaned_sql += f" LIMIT {MAX_ROWS}"

        # Step 3: Scope query to the current user where applicable
        # The LLM should already include user_id filters, but we add a safety note
        # in case it didn't. The read-only role provides the main protection.

        # Step 4: Execute against the read-only connection
        try:
            async with readonly_session() as session:
                result = await session.execute(
                    text(cleaned_sql),
                    {"user_id": str(user_id)},
                )
                rows = result.fetchall()
                columns = list(result.keys())

                # Format results
                formatted_rows = [
                    {
                        col: self._serialize_value(row[i])
                        for i, col in enumerate(columns)
                    }
                    for row in rows
                ]

                logger.info(
                    "Text-to-SQL returned %d rows for user %s",
                    len(formatted_rows),
                    user_id,
                )

                return {
                    "status": "success",
                    "question": question,
                    "sql_executed": cleaned_sql,
                    "columns": columns,
                    "rows": formatted_rows,
                    "row_count": len(formatted_rows),
                    "truncated": len(rows) >= MAX_ROWS,
                }

        except Exception as e:
            error_msg = str(e)
            # Don't expose internal DB errors to the user
            if "statement timeout" in error_msg.lower():
                user_error = "The query took too long to execute. Try simplifying it."
            elif "permission denied" in error_msg.lower():
                user_error = "The query tried to access restricted data."
            else:
                user_error = f"Query execution failed: {error_msg}"

            logger.error("Text-to-SQL execution error: %s", error_msg)

            return {
                "status": "error",
                "question": question,
                "error": user_error,
            }

    def _serialize_value(self, value: Any) -> Any:
        """Serialize a database value to JSON-safe format."""
        if value is None:
            return None
        if isinstance(value, (int, float, str, bool)):
            return value
        # Handle Decimal, date, datetime, UUID, etc.
        return str(value)
